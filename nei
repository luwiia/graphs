#include <iostream>
#include <climits>;
using namespace std;
const int inf = INT_MAX;


int** create(int n) {
    int** mat = new int* [n];
    for (int i = 0; i < n; i++) {
        mat[i] = new int[n];
    }
    return mat;
}

void del(int** mat, int n) {
    for (int i = 0; i < n; i++) {
        delete[] mat[i];
    }
    delete[] mat;
}

void ini(int** gra, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j)  (gra[i][j] = 0);
            else
                gra[i][j] = inf;
        }
    }
}

int min(int a1, int a2) {
    if (a2 > a1)
        return a1;
    else
        return a2;
}

void print(int** mat, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (mat[i][j] == inf)
                cout << "inf\t";
            else
                cout << mat[i][j] << "\t";
        }
        cout << endl;
    }
    cout << endl;
}

// Поиск центра графа (использует алгоритм Флойда)
void findCenter(int** graph, int n) {
    cout << "\n=== ПОИСК ЦЕНТРА ГРАФА ===\n";
    
    // 1. Сначала находим все кратчайшие пути (алгоритм Флойда)
    int** dist = create(n);
    
    // Копируем граф
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = graph[i][j];
        }
    }
    
    // Алгоритм Флойда
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != inf && dist[k][j] != inf) {
                    int newdist = dist[i][k] + dist[k][j];
                    if (newdist < dist[i][j]) {
                        dist[i][j] = newdist;
                    }
                }
            }
        }
    }
    
    cout << "Матрица кратчайших расстояний:\n";
    print(dist, n);
    
    // 2. Находим эксцентриситет каждой вершины
    int* eccentricity = new int[n];
    cout << "\nЭксцентриситеты вершин:\n";
    
    for (int i = 0; i < n; i++) {
        int maxDist = 0;
        for (int j = 0; j < n; j++) {
            if (i != j && dist[i][j] > maxDist && dist[i][j] != inf) {
                maxDist = dist[i][j];
            }
        }
        eccentricity[i] = maxDist;
        cout << "Вершина " << i << ": " << maxDist << "\n";
    }
    
    // 3. Находим радиус и центр
    int radius = inf;
    for (int i = 0; i < n; i++) {
        if (eccentricity[i] < radius) {
            radius = eccentricity[i];
        }
    }
    
    cout << "\nРАДИУС графа: " << radius << "\n";
    cout << "ЦЕНТР графа (вершины с минимальным эксцентриситетом): ";
    
    bool first = true;
    for (int i = 0; i < n; i++) {
        if (eccentricity[i] == radius) {
            if (!first) cout << ", ";
            cout << i;
            first = false;
        }
    }
    cout << "\n";
    
    delete[] eccentricity;
    del(dist, n);
}

// Алгоритм Прима (минимальное остовное дерево)
void prim(int** graph, int n) {
    cout << "\n=== АЛГОРИТМ ПРИМА (минимальное остовное дерево) ===\n";
    
    int* parent = new int[n];    // родитель вершины в MST
    int* key = new int[n];       // минимальный вес ребра
    bool* inMST = new bool[n];   // вершина в MST
    
    // Инициализация
    for (int i = 0; i < n; i++) {
        key[i] = inf;
        inMST[i] = false;
        parent[i] = -1;
    }
    
    // Начинаем с вершины 0
    key[0] = 0;
    
    int totalWeight = 0;
    
    // Строим MST из n вершин
    for (int count = 0; count < n; count++) {
        // 1. Находим вершину с минимальным key, не входящую в MST
        int minKey = inf;
        int u = -1;
        
        for (int v = 0; v < n; v++) {
            if (!inMST[v] && key[v] < minKey) {
                minKey = key[v];
                u = v;
            }
        }
        
        if (u == -1) break;
        
        // 2. Добавляем вершину в MST
        inMST[u] = true;
        
        // 3. Обновляем ключи соседей
        for (int v = 0; v < n; v++) {
            if (graph[u][v] != 0 && graph[u][v] != inf && !inMST[v] && graph[u][v] < key[v]) {
                key[v] = graph[u][v];
                parent[v] = u;
            }
        }
    }
    
    // Выводим результат
    cout << "Минимальное остовное дерево:\n";
    cout << "Ребро \tВес\n";
    
    for (int i = 1; i < n; i++) {
        if (parent[i] != -1) {
            cout << parent[i] << " - " << i << " \t" << graph[i][parent[i]] << "\n";
            totalWeight += graph[i][parent[i]];
        }
    }
    
    cout << "Общий вес MST: " << totalWeight << "\n";
    
    delete[] parent;
    delete[] key;
    delete[] inMST;
}

// Структура для ребра (для алгоритма Крускала)
struct Edge {
    int u, v, weight;
};

// Функция сравнения для сортировки (пузырьковая сортировка)
void bubbleSort(Edge edges[], int m) {
    for (int i = 0; i < m - 1; i++) {
        for (int j = 0; j < m - i - 1; j++) {
            if (edges[j].weight > edges[j + 1].weight) {
                // Меняем местами
                Edge temp = edges[j];
                edges[j] = edges[j + 1];
                edges[j + 1] = temp;
            }
        }
    }
}

// Нахождение корня множества
int findParent(int parent[], int i) {
    while (parent[i] != i) {
        i = parent[i];
    }
    return i;
}

// Объединение двух множеств
void unionSets(int parent[], int rank[], int x, int y) {
    int rootX = findParent(parent, x);
    int rootY = findParent(parent, y);
    
    if (rootX != rootY) {
        // Присоединяем меньшее дерево к большему
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
}

// Алгоритм Крускала (минимальное остовное дерево)
void kruskal(int** graph, int n) {
    cout << "\n=== АЛГОРИТМ КРУСКАЛА (минимальное остовное дерево) ===\n";
    
    // Собираем все ребра графа
    Edge* edges = new Edge[n * n];  // максимально возможное количество ребер
    int m = 0;  // количество ребер
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (graph[i][j] != 0 && graph[i][j] != inf) {
                edges[m].u = i;
                edges[m].v = j;
                edges[m].weight = graph[i][j];
                m++;
            }
        }
    }
    
    if (m == 0) {
        cout << "Граф не содержит ребер!\n";
        delete[] edges;
        return;
    }
    
    // Сортируем ребра по весу (по возрастанию)
    bubbleSort(edges, m);
    
    // Система непересекающихся множеств
    int* parent = new int[n];
    int* rank = new int[n];
    
    for (int i = 0; i < n; i++) {
        parent[i] = i;  // каждая вершина - свое множество
        rank[i] = 0;
    }
    
    // Минимальное остовное дерево
    Edge* result = new Edge[n - 1];
    int e = 0;  // количество ребер в результате
    int totalWeight = 0;
    
    // Проходим по отсортированным ребрам
    for (int i = 0; i < m && e < n - 1; i++) {
        Edge nextEdge = edges[i];
        
        int x = findParent(parent, nextEdge.u);
        int y = findParent(parent, nextEdge.v);
        
        // Если ребро не создает цикл
        if (x != y) {
            result[e] = nextEdge;
            e++;
            totalWeight += nextEdge.weight;
            unionSets(parent, rank, x, y);
        }
    }
    
    // Выводим результат
    if (e == n - 1) {
        cout << "Минимальное остовное дерево:\n";
        cout << "Ребро \tВес\n";
        
        for (int i = 0; i < e; i++) {
            cout << result[i].u << " - " << result[i].v << " \t" << result[i].weight << "\n";
        }
        
        cout << "Общий вес MST: " << totalWeight << "\n";
    } else {
        cout << "Не удалось построить MST (граф несвязный)\n";
    }
    
    delete[] edges;
    delete[] parent;
    delete[] rank;
    delete[] result;
}

int main() {
    // Создаем граф с 5 вершинами
    int n = 5;
    int** graph = create(n);
    ini(graph, n);
    
    // Неориентированный взвешенный граф
    graph[0][1] = graph[1][0] = 2;
    graph[0][3] = graph[3][0] = 6;
    graph[1][2] = graph[2][1] = 3;
    graph[1][3] = graph[3][1] = 8;
    graph[1][4] = graph[4][1] = 5;
    graph[2][4] = graph[4][2] = 7;
    graph[3][4] = graph[4][3] = 9;
    
    // Добавляем INF для отсутствующих ребер
    graph[0][2] = graph[2][0] = inf;
    graph[0][4] = graph[4][0] = inf;
    graph[2][3] = graph[3][2] = inf;
    
    cout << "Исходный граф:\n";
    print(graph, n);
    
    // 1. Поиск центра графа
    findCenter(graph, n);
    
    // 2. Алгоритм Прима
    prim(graph, n);
    
    // 3. Алгоритм Крускала
    kruskal(graph, n);
    
    del(graph, n);
    return 0;
}
