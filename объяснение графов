### 1. Алгоритм Флойда-Уоршелла

**Суть:** Находит кратчайшие пути **между всеми** парами вершин сразу.
**Как работает:** Представь, что ты хочешь доехать из города А в город Б. Ты проверяешь: «А станет ли путь короче, если я заеду в город К по пути?». Алгоритм перебирает все возможные города К (промежуточные точки) для каждой пары А и Б. Если путь через К короче, чем прямой, мы записываем этот новый результат в таблицу.

---

### 2. Алгоритм Дейкстры

**Суть:** Ищет кратчайший путь от **одной конкретной** вершины до всех остальных.
**Как работает:** Это «жадный» алгоритм. Мы стоим в начальной точке. Смотрим на соседей и записываем расстояние до них. Потом выбираем самого близкого соседа, переходим в него и смотрим: «А могу ли я отсюда дойти до его соседей быстрее, чем знал раньше?». Мы никогда не возвращаемся назад, всегда выбираем самый дешевый текущий вариант.

---

### 3. Алгоритм Прима

**Суть:** Строит «дешевый каркас» (минимальное остовное дерево) — соединяет все вершины так, чтобы общая сумма весов ребер была минимальной, и при этом не было циклов.
**Как работает:** Начинаем с любой одной вершины. Она — наше «дерево», которое начинает расти. Мы смотрим на все ребра, которые выходят из нашего дерева в «дикий лес» (к неподключенным вершинам), и выбираем самое короткое. Добавляем вершину, к которой оно вело, в наше дерево. Повторяем, пока не подключим всех.

---

### 4. Алгоритм Крускала

**Суть:** Тоже строит «дешевый каркас», но другим способом.
**Как работает:** Представь, что у тебя есть куча разрозненных островов. Ты выписываешь все возможные мосты и сортируешь их от самых дешевых до самых дорогих. Берешь самый дешевый мост и строишь его. Берешь следующий... Главное правило: если мост соединяет два острова, которые **уже** соединены (даже через другие острова), мы его не строим, чтобы не тратить деньги зря. В итоге все острова соединятся в один материк.

---

### 5. Центр графа

**Суть:** Находит «самую удобную» вершину, из которой до самой дальней точки графа добираться быстрее, чем из любой другой.
**Как работает:** Сначала мы считаем все расстояния (Флойдом). Для каждой вершины мы смотрим, какая точка от нее дальше всего (это называется эксцентриситет). Тот «счастливчик», у которого это максимальное расстояние окажется самым маленьким среди всех остальных — и есть центр. Идеальное место для постройки пожарной станции или склада.

---

### 6. Сильная связность

**Суть:** Проверяет, можно ли в ориентированном графе (где дороги с односторонним движением) добраться из **любой** точки в **любую** другую.
**Как работает:** Если ты можешь выехать из города А, объехать все города и вернуться в А, и так можно сделать для каждого города — граф сильно связан. В коде мы просто запускаем человечка из каждой вершины: если он хотя бы раз не смог обойти весь граф по стрелкам — значит, есть «тупики» или изолированные районы, и сильной связности нет.










### 1. Алгоритм Флойда (floyd)

**В коде:** Три вложенных цикла `for (k, i, j)`.

* **Что происходит:** Мы берем таблицу `dist` и начинаем её обновлять.
* **Главная строчка:** `if (dist[i][k] + dist[k][j] < dist[i][j])`.
* **Логика:** Мы спрашиваем программу: «Слушай, а если идти из города `i` в город `j` не напрямую, а через город `k`, будет быстрее?». Если через `k` быстрее, мы стираем старое число и записываем новую, более короткую дорогу.
* **Итог:** После завершения циклов в таблице будут самые короткие пути вообще между всеми точками.

---

### 2. Алгоритм Дейкстры (dei)

**В коде:** Массив `dist` для расстояний и `vis` для отметок «был здесь».

* **Что происходит:** 1. Мы находим вершину `u`, в которую дойти дешевле всего из тех, где мы еще не были (`dist[v] < mindist`).
2. Помечаем её `vis[u] = true`.
3. Смотрим на всех её соседей `v`. Если путь через `u` до соседа короче, чем тот, что мы знали раньше, обновляем `dist[v]`.
* **Суть:** Это жадный поиск. Мы каждый раз выбираем самый выгодный шаг прямо сейчас.

---

### 3. Алгоритм Прима (prim)

**В коде:** Массив `key` (стоимость подключения) и `inMST` (уже в остове).

* **Что происходит:** Очень похоже на Дейкстру, но есть важное отличие!
* **Главная деталь:** В Дейкстре мы копим общее расстояние от старта (`dist[u] + graph[u][v]`), а в Приме нам важен **только вес одного самого дешевого ребра**, чтобы подтянуть новую вершину к нашему «облаку».
* **Логика:** Мы ищем самое дешевое ребро, которое торчит из нашего уже собранного куска графа наружу.

---

### 4. Алгоритм Крускала (kruskal)

**В коде:** Три массива `u_arr, v_arr, w_arr` и функция `findSet`.

* **Что происходит:** 1. Сначала мы выписали все ребра и отсортировали их «пузырьком» по весу.
2. Потом идем по списку от самых маленьких ребер к большим.
3. Функция `findSet` проверяет: «А не принадлежат ли эти две точки уже одному и тому же дереву?».
* **Суть:** Если точки в разных компаниях — соединяем их. Если в одной — выкидываем ребро, иначе получится круг (цикл), а нам нужно дерево.

---

### 5. Центр графа (findCenter)

**В коде:** Сначала вызывается логика Флойда, потом ищется `minEcc`.

* **Что происходит:** 1. Сначала мы получили таблицу всех расстояний.
2. Для каждой строки (вершины) мы нашли самое большое число — это её «край географии» (максимальное расстояние до самой дальней точки).
3. Потом мы сравнили эти «максимумы» у всех вершин и выбрали того, у кого этот максимум — самый маленький.
* **Суть:** Мы нашли вершину, которая находится «в гуще событий».

---

### 6. Сильная связность (strong)

**В коде:** Цикл `for`, внутри которого вызывается `dfs`.

* **Что происходит:** 1. Мы по очереди заходим в каждую вершину.
2. Из каждой вершины запускаем «разведчика» `dfs`. Он идет по всем доступным дорогам и метит их в массиве `vis`.
3. После каждого захода проверяем: «Все ли города помечены?». Если хоть один остался белым — значит, из этой точки нельзя попасть во все остальные.
* **Суть:** Мы проверяем «честность» графа — нет ли в нем улиц с односторонним движением, которые заведут нас в тупик, откуда не выбраться.
